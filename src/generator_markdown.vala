/* generator_markdown.vala
 *
 * Copyright 2023 Mibi88
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * SPDX-License-Identifier: GPL-2.0-or-later
 */

using GLib;

public enum Token {
    T_TITLE_H1,
    T_TITLE_H2,
    T_TITLE_H3,
    T_TITLE_H4,
    T_TITLE_H5,
    T_TITLE_H6,
    T_BOLD,
    T_ITALIC,
    T_STRIKETROUGH,
    T_CODE,
    T_INLINECODE,
    T_HR,
    T_AMOUNT
}

public class Generator_MD : Generator {
    public new bool allow_html = true;
    private string html_data;
    private bool open[Token.T_AMOUNT];
    private const string TOKEN_STARTS = "#*_~-`";
    private const string TOKEN_CONTENT = "#*_~-`";
    bool token_endsonlineend;
    Token endsonlineend_token;
    private const string token_start[Token.T_AMOUNT] = {
        "#",
        "##",
        "###",
        "####",
        "#####",
        "######",
        "**",
        "*",
        "~~",
        "```",
        "`",
        "---"
    };
    private const string token_end[Token.T_AMOUNT] = {
        "",
        "",
        "",
        "",
        "",
        "",
        "**",
        "*",
        "~~",
        "```",
        "`",
        ""
    };
    private const string token_html_start[Token.T_AMOUNT] = {
        "<h1>",
        "<h2>",
        "<h3>",
        "<h4>",
        "<h5>",
        "<h6>",
        "<b>",
        "<i>",
        "<s>",
        "<br><code>",
        "<code>",
        "<hr>"
    };
    private const string token_html_end[Token.T_AMOUNT] = {
        "</h1>",
        "</h2>",
        "</h3>",
        "</h4>",
        "</h5>",
        "</h6>",
        "</b>",
        "</i>",
        "</s>",
        "<br></code>",
        "</code>",
        ""
    };
    private const bool TOKEN_ENDS_ON_LINEEND[Token.T_AMOUNT] = {
        true, // H1
        true, // H2
        true, // H3
        true, // H4
        true, // H5
        true, // H6
        false, // Bold
        false, // Italic
        false, // Striketrough
        false, // Multiline code
        false, // Inline code
        true, // Horizontal line code
    };
    private string get_token (string token) {
        bool token_isstart = true;
        int pos = -1;
        for (int i=0;i<Token.T_AMOUNT;i++) {
            if (token_end[i] == token) {
                token_isstart = false;
                pos = i;
                break;
            } else if (token_start[i] == token) {
                token_isstart = true;
                pos = i;
                break;
            }
        }
        if (pos >= 0) { // The token exists
            if (TOKEN_ENDS_ON_LINEEND[pos]) {
                token_endsonlineend = true;
                endsonlineend_token = (Token) pos;
            }
            if (token_isstart || !open[pos]){
                open[pos] = true;
                return token_html_start[pos];
            } else {
                open[pos] = false;
                return token_html_end[pos];
            }
        } else { // if he doesn't, return the token
            return token;
        }
    }
    public override string generate_html (string md_data) {
        string data = md_data.replace ("\n\n", "\n<br>\n"); // Line jumps
        html_data = """<!-- Generated by MibiMdEditor -->
<!DOCTYPE html>
<html>
<body>""";
        bool escaped = false;
        bool is_token = false;
        string token_data = "";
        // Set all bools to false in open
        for (int i=0;i<Token.T_AMOUNT;i++) open[i] = false;
        token_endsonlineend = false;
        char c;
        for(int i=0;i<data.length;i++) {
            c = data[i];
            // Set escaped to true because the char that will be parsed is
            // escaped
            if (c == '\\') {
                escaped = true;
                // Skip this char
                if (i+1 < data.length) {
                    i++;
                    c = data[i];
                }
            }
            // A new token starts
            if (!is_token && c.to_string() in TOKEN_STARTS && !escaped) {
                is_token = true;
                token_data = "";
            }
            bool still_in_token = c.to_string() in TOKEN_CONTENT;
            // The token ends
            if (is_token && (!still_in_token || escaped)) {
                // Add the right html code to the output data
                html_data += get_token (token_data);
                is_token = false;
            }
            if (c == '\n' && token_endsonlineend) {
                if (TOKEN_ENDS_ON_LINEEND[endsonlineend_token]) {
                    html_data += token_html_end[endsonlineend_token];
                    open[endsonlineend_token] = false;
                    token_endsonlineend = false;
                }
            }
            // If we're in a token, we put his content into the token string
            if (is_token) {
                token_data += c.to_string();
            } else {
                // Else we put it directly to the html code
                // TODO : Escape HTML if allow_html is false
                html_data += c.to_string();
            }
            escaped = false;

        }
        if (token_endsonlineend) {
            if (TOKEN_ENDS_ON_LINEEND[endsonlineend_token]) {
                html_data += token_html_end[endsonlineend_token];
                open[endsonlineend_token] = false;
            }
        }
        html_data += "</body>\n</html>";
        return html_data;
    }
}
